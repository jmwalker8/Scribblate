<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scribblate</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <style>
      :root {
        --primary: #4169e1;
        --success: #22c55e;
        --background: #ffffff;
        --text: #333333;
        --secondary: #666666;
        --border: #e5e7eb;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          sans-serif;
      }

      body {
        background: var(--background);
        min-height: 100vh;
        display: flex;
        padding: 2rem;
      }

      .container {
        max-width: 1200px;
        width: 100%;
        margin: 0 auto;
        display: flex;
        gap: 2rem;
      }

      .sidebar {
        width: 300px;
        flex-shrink: 0;
      }

      .main-content {
        flex: 1;
        background: white;
        border-radius: 12px;
        padding: 2rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .mood-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 2rem;
      }

      .mood-button {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 20px;
        background: #f3f4f6;
        color: var(--secondary);
        cursor: pointer;
        font-size: 1rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .mood-button i {
        font-size: 0.9rem;
      }

      .mood-button.active {
        background: var(--primary);
        color: white;
      }

      .add-mood-button {
        background: transparent;
        border: 2px dashed var(--border);
        color: var(--secondary);
      }

      .prompt-banner {
        background: linear-gradient(135deg, var(--primary), #7c3aed);
        color: white;
        padding: 2rem;
        border-radius: 12px;
        margin-bottom: 2rem;
        text-align: center;
        font-size: 1.2rem;
        position: relative;
        overflow: hidden;
      }

      .prompt-banner::before {
        content: '"';
        position: absolute;
        font-size: 8rem;
        opacity: 0.1;
        top: -2rem;
        left: 1rem;
      }

      .timer {
        text-align: center;
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 2rem;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
      }

      .timer i {
        font-size: 2rem;
        color: var(--secondary);
      }

      .message {
        text-align: center;
        color: var(--primary);
        margin-bottom: 2rem;
        font-size: 1.1rem;
      }

      .success-message {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        color: var(--success);
      }

      .success-message i {
        font-size: 3rem;
        animation: checkmark 0.5s ease-in-out;
      }

      @keyframes checkmark {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .story-preview {
        background: #f8fafc;
        padding: 1.5rem;
        border-radius: 12px;
        color: var(--secondary);
        min-height: 100px;
        line-height: 1.6;
      }

      .phase-dots {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin-top: 2rem;
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--border);
        transition: background-color 0.3s;
      }

      .dot.active {
        background: var(--primary);
      }

      .writing-area {
        width: 100%;
        min-height: 200px;
        padding: 1.5rem;
        border: 2px solid var(--border);
        border-radius: 12px;
        font-size: 1.1rem;
        resize: none;
        display: none;
        line-height: 1.6;
      }

      .writing-area:focus {
        outline: none;
        border-color: var(--primary);
      }

      .collaborators {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }

      .collaborator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: #f3f4f6;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
      }

      .user-avatar, /* For any user avatars */
.author-avatar, /* For contribution author avatars */
.collaborator img, /* For active writers */
.viewer img { /* For viewers */
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover; /* This ensures the image maintains aspect ratio */
}

.contribution .author-avatar {
    width: 24px;
    height: 24px;
}

      .sidebar-card {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .sidebar-card h3 {
        margin-bottom: 1rem;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .add-prompt-button {
        background: none;
        border: none;
        color: var(--primary);
        cursor: pointer;
        font-size: 1.2rem;
      }

      .custom-prompts {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .prompt-item {
        background: #f3f4f6;
        padding: 0.75rem;
        border-radius: 8px;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .prompt-item button {
        background: none;
        border: none;
        color: var(--secondary);
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .prompt-item:hover button {
        opacity: 1;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
        padding: 1rem;
      }

      .modal-content {
        background: white;
        padding: 2rem;
        border-radius: 12px;
        max-width: 500px;
        width: 100%;
      }

      .modal h2 {
        margin-bottom: 1rem;
      }

      .modal input {
        width: 100%;
        padding: 0.75rem;
        border: 2px solid var(--border);
        border-radius: 8px;
        margin-bottom: 1rem;
      }

      .author-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

      .modal-buttons {
        display: flex;
        gap: 1rem;
        justify-content: flex-end;
      }

      .modal-button {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
      }

      .modal-button.primary {
        background: var(--primary);
        color: white;
      }

      .modal-button.secondary {
        background: #f3f4f6;
        color: var(--secondary);
      }

      .contribution {
    border-left: 3px solid var(--primary);
    padding: 1rem;
    margin-bottom: 1rem;
    background: white;
    border-radius: 0 8px 8px 0;
}

contribution-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    color: var(--secondary);
}

      .reactions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      

      .reaction-button {
        background: none;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.25rem;
        transition: all 0.2s;
        color: var(--secondary);
      }

      .reaction-button:hover {
        background: #f3f4f6;
      }

      .reaction-button.active {
        background: var(--primary);
        color: white;
      }

      .reaction-count {
        font-size: 0.8rem;
      }

      .reaction-pop {
        animation: reactionPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      @keyframes reactionPop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.4);
        }
        100% {
          transform: scale(1);
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      .success-details {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }

        .sidebar {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <!-- Custom Prompts Section -->
        <div class="sidebar-card">
          <h3>Custom Prompts</h3>
          <div class="custom-prompts">
            <!-- User's custom prompts will be listed here -->
          </div>
          <button class="add-prompt-button" onclick="showAddPromptModal()">
            <i class="fas fa-plus"></i>
          </button>
        </div>

        <!-- Active Writers Section -->
        <div class="sidebar-card">
          <h3>Active Writers</h3>
          <div id="activeWriters" class="collaborators">
            <!-- Active writers will be shown here -->
          </div>
        </div>

        <!-- Viewers Section -->
        <div class="sidebar-card">
          <h3>Viewers <span id="viewerCount" class="viewer-count">0</span></h3>
          <div id="activeViewers" class="collaborators">
            <!-- Viewers will be shown here -->
          </div>
        </div>
      </div>

      <div class="stories-container" style="display: none">
        <div class="stories-header">
          <h2>Completed Stories</h2>
          <div class="stories-filters">
            <select id="categoryFilter">
              <option value="all">All Categories</option>
              <option value="creative">Creative</option>
              <option value="mysterious">Mysterious</option>
              <option value="adventure">Adventure</option>
            </select>
            <select id="timeFilter">
              <option value="recent">Most Recent</option>
              <option value="popular">Most Popular</option>
            </select>
          </div>
        </div>

        <div id="storiesList" class="stories-grid">
          <!-- Stories will be populated here -->
        </div>
      </div>

      <div class="main-content">
        <div class="mood-selector">
          <button class="mood-button active" data-mood="creative">
            <i class="fas fa-lightbulb"></i>
            Creative
          </button>
          <button class="mood-button" data-mood="mysterious">
            <i class="fas fa-moon"></i>
            Mysterious
          </button>
          <button class="mood-button" data-mood="adventure">
            <i class="fas fa-mountain"></i>
            Adventure
          </button>
          <button class="mood-button" data-mood="romantic">
            <i class="fas fa-heart"></i>
            Romantic
          </button>
          <button class="mood-button" data-mood="sci-fi">
            <i class="fas fa-robot"></i>
            Sci-Fi
          </button>
          <button
            class="mood-button add-mood-button"
            onclick="showAddMoodModal()"
          >
            <i class="fas fa-plus"></i>
            Add Mood
          </button>
        </div>

        <div class="prompt-banner">Loading prompt...</div>

        <div class="timer">
          <i class="far fa-clock"></i>
          <span id="timerDisplay">45</span>
        </div>

        <div class="message">Take a moment to gather your thoughts...</div>

        <!-- Add this right after the message div -->
        <div class="brainstorm-content fade show">
          <div class="story-preview">
            <!-- Story preview will appear here -->
          </div>
        </div>

        <textarea
          class="writing-area"
          placeholder="Let your creativity flow..."
        ></textarea>

        <div class="wait-message fade" style="display: none">
          <div class="success-message">
            <i class="fas fa-check-circle pulse"></i>
            <span>Great job! Your contribution has been added.</span>
          </div>
        </div>

        <div class="phase-dots">
          <div class="dot active"></div>
          <div class="dot"></div>
          <div class="dot"></div>
        </div>
      </div>
    </div>

    <!-- Add Prompt Modal -->
    <div id="addPromptModal" class="modal">
      <div class="modal-content">
        <h2>Add Custom Prompt</h2>
        <input
          type="text"
          id="newPromptInput"
          placeholder="Enter your prompt..."
        />
        <div class="modal-buttons">
          <button
            class="modal-button secondary"
            onclick="closeModal('addPromptModal')"
          >
            Cancel
          </button>
          <button class="modal-button primary" onclick="saveCustomPrompt()">
            Add Prompt
          </button>
        </div>
      </div>
    </div>

    <!-- Add Mood Modal -->
    <div id="addMoodModal" class="modal">
      <div class="modal-content">
        <h2>Add Custom Mood</h2>
        <input type="text" id="newMoodInput" placeholder="Enter mood name..." />
        <div class="modal-buttons">
          <button
            class="modal-button secondary"
            onclick="closeModal('addMoodModal')"
          >
            Cancel
          </button>
          <button class="modal-button primary" onclick="saveCustomMood()">
            Add Mood
          </button>
        </div>
      </div>
    </div>
    <script type="module">
      
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
      } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
      import {
        getDatabase,
        ref,
        push,
        set,
        onValue,
        get,
        remove,
        onDisconnect,
      } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';

      // Firebase configuration
      const firebaseConfig = {
        apiKey: 'AIzaSyD5cPsewQLJEqkzxqSGX-QZQmrK-dxpvaM',
        authDomain: 'scribblate-ce00a.firebaseapp.com',
        projectId: 'scribblate-ce00a',
        storageBucket: 'scribblate-ce00a.firebasestorage.app',
        messagingSenderId: '752237311953',
        appId: '1:752237311953:web:5d9425779169a9b80752f0',
        measurementId: 'G-B47QVGX24Y',
        databaseURL: 'https://scribblate-ce00a-default-rtdb.firebaseio.com',
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const database = getDatabase(app);

      // App state
     
      class AppState {
    constructor() {
        this.currentUser = null;
        this.currentStoryId = null;
        this.currentPhase = 'brainstorm';
        this.timeLeft = 45;
        this.currentMood = 'creative';
        this.isInitialized = false;
        this.listeners = new Set();
    }

    update(changes) {
        Object.assign(this, changes);
        this.notifyListeners();
    }

    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }

    notifyListeners() {
        this.listeners.forEach(listener => listener(this));
    }
}

const appState = new AppState();

      // Default prompts
      const defaultPrompts = {
        creative: [
          'In a world where shadows could speak...',
          'The old typewriter began typing by itself...',
          'When the colors started fading from the world...',
        ],
        mysterious: [
          'The letter arrived exactly one year after...',
          'The footprints in the snow led nowhere...',
          'Every night at midnight, the painting changed...',
        ],
        adventure: [
          "The map showed a location that shouldn't exist...",
          'Through the mist, a strange ship appeared...',
          'The ancient door had five different keyholes...',
        ],
        romantic: [
          'Their letters crossed in the mail...',
          'The music box played a forgotten melody...',
          'Two umbrellas collided on a rainy day...',
        ],
        'sci-fi': [
          'The android discovered it could dream...',
          'Time began flowing backwards at midnight...',
          'The stars started disappearing one by one...',
        ],
      };

      // Achievements system
      const achievements = {
        firstStory: {
          id: 'firstStory',
          title: 'First Story',
          description: 'Contributed to your first story',
          icon: 'fa-book',
        },
        speedWriter: {
          id: 'speedWriter',
          title: 'Speed Writer',
          description: 'Wrote over 100 words in one session',
          icon: 'fa-bolt',
        },
        nightOwl: {
          id: 'nightOwl',
          title: 'Night Owl',
          description: 'Wrote between midnight and 4 AM',
          icon: 'fa-moon',
        },
      };

      // Utility Functions
      function formatTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = (now - date) / 1000;

        if (diff < 60) return 'just now';
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return date.toLocaleDateString();
      }

      function getStoryPreview(contributions) {
        if (!contributions) return '';
        const preview = Object.values(contributions)
          .map((c) => c.content)
          .join(' ');
        return preview.slice(0, 200) + '...';
      }

      function updatePrompt(mood) {
        const prompts = defaultPrompts[mood] || defaultPrompts.creative;
        const randomPrompt =
          prompts[Math.floor(Math.random() * prompts.length)];
        const promptBanner = document.querySelector('.prompt-banner');
        if (promptBanner) {
          promptBanner.textContent = randomPrompt;
        }
      }

      // Post contribution styles and HTML
  

      // PostContributionHandler Class
      class PostContributionHandler {
    constructor() {
        this.container = null;
        this.storyContainer = null;
        this.initialized = false;
        this.setupUI();
    }

    setupUI() {
        try {
            // Add styles if they don't exist
            if (!document.querySelector('style[data-type="post-contribution"]')) {
                const style = document.createElement('style');
                style.setAttribute('data-type', 'post-contribution');
                style.textContent = postContributionStyles;
                document.head.appendChild(style);
            }

            // Add HTML if it doesn't exist
            if (!document.querySelector('.post-contribution')) {
                document.body.insertAdjacentHTML('beforeend', postContributionHTML);
            }

            // Initialize container references
            this.container = document.querySelector('.post-contribution');
            if (this.container) {
                this.storyContainer = this.container.querySelector('.full-story');
                this.initialized = true;
            }
        } catch (error) {
            console.error('Error setting up PostContributionHandler:', error);
            this.initialized = false;
        }
    }

    async showPostContribution(contributionId) {
        if (!this.initialized) {
            this.setupUI();
            if (!this.initialized) {
                console.error('PostContributionHandler not properly initialized');
                return;
            }
        }

        try {
            const storyRef = ref(database, `stories/${currentStoryId}`);
            const snapshot = await get(storyRef);
            const story = snapshot.val();

            if (!story) return;

            this.renderStory(story, contributionId);
            this.container.classList.add('show');
            await this.trackStoryView();
        } catch (error) {
            console.error('Error showing post-contribution:', error);
        }
    }

    renderStory(story, highlightedContributionId) {
        if (!this.storyContainer) {
            console.error('Story container not found');
            return;
        }

        const contributions = story.contributions || {};
        const sortedContributions = Object.entries(contributions)
            .sort(([, a], [, b]) => a.timestamp - b.timestamp);

        this.storyContainer.innerHTML = sortedContributions
            .map(([id, contribution]) => `
                <div class="contribution ${id === highlightedContributionId ? 'contribution-highlight' : ''}">
                    <div class="contribution-meta">
                        <div class="author-info">
                            <img src="${contribution.userPhoto}" alt="${contribution.userName}" class="author-avatar">
                            <span>${contribution.userName}</span>
                        </div>
                        <span>${formatTime(contribution.timestamp)}</span>
                    </div>
                    <p>${contribution.content}</p>
                    <div class="reactions">
                        ${this.renderReactions(contribution.reactions || {}, id)}
                    </div>
                </div>
            `).join('');
    }

    hide() {
        if (this.container) {
            this.container.classList.remove('show');
        }
    }
}

        

      // StoryFlowManager Class
      // Update StoryFlowManager's timer usage
class StoryFlowManager {
    constructor() {
        this.currentPhase = null;
        this.timer = new SyncedTimer(database);
        this.collaborationManager = null;
    }

    async initialize() {
        try {
            // Check if this is a new story or joining existing
            const isNewStory = localStorage.getItem('isNewStory') === 'true';
            
            if (isNewStory) {
                const story = await this.createNewStory();
                appState.update({ currentStoryId: story.id });
                
                // Start with brainstorm phase for new story
                this.currentPhase = 'brainstorm';
                const promptBanner = document.querySelector('.prompt-banner');
                if (promptBanner) {
                    promptBanner.textContent = story.prompt;
                }
            } else {
                // Get existing story ID
                const storyId = localStorage.getItem('storyId');
                if (!storyId) throw new Error('No story ID found');
                
                appState.update({ currentStoryId: storyId });
                
                // Get story data
                const storyRef = ref(database, `stories/${storyId}`);
                const snapshot = await get(storyRef);
                const story = snapshot.val();
                
                if (!story) throw new Error('Story not found');
                
                // Show prompt
                const promptBanner = document.querySelector('.prompt-banner');
                if (promptBanner) {
                    promptBanner.textContent = story.prompt;
                }
                
                // Start with reading phase for existing story
                this.currentPhase = 'reading';
            }
            
            // Initialize timer and start first phase
            await this.startTimer();
            
            // Initialize collaboration manager
            this.collaborationManager = new CollaborationManager(
                appState.currentStoryId, 
                database, 
                appState.currentUser
            );
            this.collaborationManager.initialize();
            
        } catch (error) {
            console.error('Error initializing story flow:', error);
            ErrorHandler.handleError(error, 'story_flow_initialization');
        }
    }

    async startPhase(phase) {
    this.currentPhase = phase;
    const message = document.querySelector('.message');
    const writingArea = document.querySelector('.writing-area');
    const storyPreview = document.querySelector('.story-preview');
    
    // Update UI based on phase
    if (phase === 'brainstorm') {
        if (message) message.textContent = 'Take a moment to gather your thoughts...';
        if (writingArea) writingArea.style.display = 'none';
        if (storyPreview) storyPreview.style.display = 'none';
    } else if (phase === 'writing') {
        if (message) message.textContent = 'Start writing your contribution...';
        if (writingArea) {
            writingArea.style.display = 'block';
            writingArea.focus();
        }
        if (storyPreview) storyPreview.style.display = 'none';
    } else if (phase === 'reading') {
        if (message) message.textContent = 'Take a moment to read what others have written...';
        if (writingArea) writingArea.style.display = 'none';
        if (storyPreview) {
            storyPreview.style.display = 'block';
            await this.updateStoryPreview();
        }
    }
    
    // Start timer
    await this.startTimer();
}

    async startTimer() {
        await this.timer.start(this.storyId, 45, () => this.handlePhaseTransition());
    }

    clearTimer() {
        if (this.timer) {
            this.timer.stop();
        }
    }

    async updateStoryPreview() {
    try {
        const storyRef = ref(database, `stories/${this.storyId}`);
        const snapshot = await get(storyRef);
        const story = snapshot.val();
        
        if (story && story.contributions) {
            const preview = document.querySelector('.story-preview');
            if (preview) {
                preview.innerHTML = Object.values(story.contributions)
                    .sort((a, b) => a.timestamp - b.timestamp)
                    .map(contribution => contribution.content)
                    .join('\n\n');
            }
        }
    } catch (error) {
        console.error('Error updating story preview:', error);
    }
}

    async createNewStory() {
        try {
            const storiesRef = ref(database, 'stories');
            const newStoryRef = push(storiesRef);

            const storyData = {
                createdAt: Date.now(),
                status: 'active',
                creator: {
                    uid: appState.currentUser.uid,
                    displayName: appState.currentUser.displayName,
                    photoURL: appState.currentUser.photoURL,
                },
                currentMood: appState.currentMood,
                prompt: this.generatePrompt(appState.currentMood),
                contributions: {},
                participants: {
                    [appState.currentUser.uid]: {
                        joinedAt: Date.now(),
                        isActive: true,
                        displayName: appState.currentUser.displayName,
                        photoURL: appState.currentUser.photoURL,
                    },
                },
            };

            await set(newStoryRef, storyData);
            return { id: newStoryRef.key, ...storyData };
        } catch (error) {
            console.error('Error creating new story:', error);
            throw error;
        }
    }

    async submitContribution() {
        const writingArea = document.querySelector('.writing-area');
        if (!writingArea) return;

        const content = writingArea.value.trim();
        if (!content) return;

        try {
            const contributionRef = push(ref(database, `stories/${this.storyId}/contributions`));
            const contribution = {
                content,
                userId: appState.currentUser.uid,
                userName: appState.currentUser.displayName,
                userPhoto: appState.currentUser.photoURL,
                timestamp: Date.now()
            };

            await set(contributionRef, contribution);
            await checkAchievements(content);
            
            // Show success message
            const message = document.querySelector('.message');
            const waitMessage = document.querySelector('.wait-message');
            if (message) message.style.display = 'none';
            if (waitMessage) {
                waitMessage.style.display = 'flex';
                setTimeout(() => {
                    waitMessage.style.display = 'none';
                    if (message) message.style.display = 'block';
                }, 2000);
            }

            // Hide writing area
            writingArea.style.display = 'none';

        } catch (error) {
            console.error('Error submitting contribution:', error);
            throw error;
        }
    }
}

// Update global functions to use appState
async function leaveCurrentStory() {
    if (!appState.currentStoryId || !appState.currentUser) return;

    try {
        const participantRef = ref(
            database,
            `stories/${appState.currentStoryId}/participants/${appState.currentUser.uid}`
        );
        await remove(participantRef);
    } catch (error) {
        console.error('Error leaving story:', error);
    }
}

function updatePrompt(mood) {
    const prompts = defaultPrompts[mood] || defaultPrompts.creative;
    const randomPrompt = prompts[Math.floor(Math.random() * prompts.length)];
    const promptBanner = document.querySelector('.prompt-banner');
    if (promptBanner) {
        promptBanner.textContent = randomPrompt;
    }
    appState.update({ currentMood: mood });
}

// Update mood button setup
function setupMoodButtons() {
    const buttons = document.querySelectorAll('.mood-button:not(.add-mood-button)');
    buttons.forEach((button) => {
        button.addEventListener('click', () => {
            buttons.forEach((b) => b.classList.remove('active'));
            button.classList.add('active');
            updatePrompt(button.dataset.mood);
        });
    });

    // Set initial active mood
    const initialMoodButton = document.querySelector(
        `.mood-button[data-mood="${appState.currentMood}"]`
    );
    if (initialMoodButton) {
        initialMoodButton.classList.add('active');
    }
}

// Update reaction handling
window.addReaction = async (contributionId, reactionType) => {
    if (!appState.currentUser || !appState.currentStoryId) return;

    try {
        const reactionRef = ref(
            database,
            `stories/${appState.currentStoryId}/contributions/${contributionId}/reactions/${reactionType}`
        );
        const snapshot = await get(reactionRef);
        const reactions = snapshot.val() || [];

        const userIndex = reactions.indexOf(appState.currentUser.uid);

        if (userIndex > -1) {
            reactions.splice(userIndex, 1);
        } else {
            reactions.push(appState.currentUser.uid);
            const button = document.querySelector(
                `[onclick="addReaction('${contributionId}', '${reactionType}')"]`
            );
            if (button) {
                button.classList.add('reaction-pop');
                setTimeout(() => button.classList.remove('reaction-pop'), 300);
            }
        }

        await set(reactionRef, reactions);
    } catch (error) {
        console.error('Error adding reaction:', error);
    }
};

      class SyncedTimer {
    constructor(database) {
        this.database = database;
        this.localInterval = null;
        this.syncInterval = null;
        this.onComplete = null;
    }

    async start(storyId, duration, onCompleteCallback) {
        this.storyId = storyId;
        this.onComplete = onCompleteCallback;
        
        try {
            const serverTime = await this.getServerTime();
            const endTime = serverTime + (duration * 1000);

            await set(ref(this.database, `stories/${storyId}/timer`), {
                startTime: serverTime,
                endTime: endTime,
                duration: duration
            });

            this.startLocalTimer(endTime);
            this.startSync();
            
        } catch (error) {
            ErrorHandler.handleError(error, 'timer_start', () => this.start(storyId, duration, onCompleteCallback));
        }
    }

    async getServerTime() {
        const offsetRef = ref(this.database, '.info/serverTimeOffset');
        const snapshot = await get(offsetRef);
        const offset = snapshot.val() || 0;
        return Date.now() + offset;
    }

    startLocalTimer(endTime) {
        if (this.localInterval) clearInterval(this.localInterval);
        
        this.localInterval = setInterval(() => {
            const remaining = this.calculateRemaining(endTime);
            this.updateDisplay(remaining);
            
            if (remaining <= 0) {
                this.stop();
                if (this.onComplete) this.onComplete();
            }
        }, 100); // Update every 100ms for smooth countdown
    }

    startSync() {
        if (this.syncInterval) clearInterval(this.syncInterval);
        
        // Listen for timer updates
        const timerRef = ref(this.database, `stories/${this.storyId}/timer`);
        onValue(timerRef, async (snapshot) => {
            const timerData = snapshot.val();
            if (timerData) {
                const serverTime = await this.getServerTime();
                const remaining = this.calculateRemaining(timerData.endTime, serverTime);
                this.updateDisplay(remaining);

                // If too far out of sync, restart local timer
                if (Math.abs(remaining - this.getLocalRemaining()) > 1) {
                    this.startLocalTimer(timerData.endTime);
                }
            }
        });
    }

    calculateRemaining(endTime, currentTime = Date.now()) {
        return Math.max(0, Math.floor((endTime - currentTime) / 1000));
    }

    getLocalRemaining() {
        const display = document.getElementById('timerDisplay');
        return display ? parseInt(display.textContent) : 0;
    }

    updateDisplay(seconds) {
        const display = document.getElementById('timerDisplay');
        if (display) {
            display.textContent = seconds;
            
            // Add visual indicators
            if (seconds <= 10) {
                display.classList.add('urgent');
            } else {
                display.classList.remove('urgent');
            }
        }
    }

    stop() {
        if (this.localInterval) {
            clearInterval(this.localInterval);
            this.localInterval = null;
        }
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
        }
    }

    async reset(duration) {
        this.stop();
        await this.start(this.storyId, duration, this.onComplete);
    }

    async pause() {
        try {
            const timerRef = ref(this.database, `stories/${this.storyId}/timer`);
            const snapshot = await get(timerRef);
            const timerData = snapshot.val();
            
            if (timerData) {
                const serverTime = await this.getServerTime();
                const remaining = this.calculateRemaining(timerData.endTime, serverTime);
                
                await set(timerRef, {
                    ...timerData,
                    isPaused: true,
                    remainingTime: remaining
                });
            }
            
            this.stop();
        } catch (error) {
            ErrorHandler.handleError(error, 'timer_pause');
        }
    }

    async resume() {
        try {
            const timerRef = ref(this.database, `stories/${this.storyId}/timer`);
            const snapshot = await get(timerRef);
            const timerData = snapshot.val();
            
            if (timerData && timerData.isPaused) {
                await this.start(this.storyId, timerData.remainingTime, this.onComplete);
            }
        } catch (error) {
            ErrorHandler.handleError(error, 'timer_resume');
        }
    }
}

class CollaborationManager {
    constructor(storyId, database, currentUser) {
        this.storyId = storyId;
        this.database = database;
        this.currentUser = currentUser;
        this.presenceRef = null;
        this.userPresenceRef = null;
    }

    initialize() {
        if (!this.storyId || !this.currentUser) return;
        
        this.setupPresence();
        this.listenToParticipantChanges();
        this.handleDisconnect();
    }

    setupPresence() {
        this.presenceRef = ref(this.database, '.info/connected');
        
        onValue(this.presenceRef, async (snapshot) => {
            if (snapshot.val()) {
                this.userPresenceRef = ref(
                    this.database,
                    `stories/${this.storyId}/participants/${this.currentUser.uid}`
                );

                // Set up disconnect cleanup
                const disconnectRef = onDisconnect(this.userPresenceRef);
                await disconnectRef.remove();

                // Add as active writer
                await set(this.userPresenceRef, {
                    displayName: this.currentUser.displayName,
                    photoURL: this.currentUser.photoURL,
                    lastActive: serverTimestamp(),
                    isActive: true
                });

                // Remove from viewers if present
                const viewerRef = ref(
                    this.database,
                    `stories/${this.storyId}/viewers/${this.currentUser.uid}`
                );
                await remove(viewerRef);
            }
        });
    }

    listenToParticipantChanges() {
        const participantsRef = ref(this.database, `stories/${this.storyId}/participants`);
        
        onValue(participantsRef, (snapshot) => {
            const participants = snapshot.val() || {};
            this.updateParticipantsUI(participants);
            this.checkParticipantLimit(participants);
        });
    }

    updateParticipantsUI(participants) {
        const container = document.getElementById('activeWriters');
        if (!container) return;

        const participantsArray = Object.entries(participants);
        const sortedParticipants = participantsArray.sort((a, b) => {
            return (a[1].joinedAt || 0) - (b[1].joinedAt || 0);
        });

        container.innerHTML = sortedParticipants.map(([uid, user]) => `
            <div class="collaborator" data-uid="${uid}">
                <img src="${user.photoURL}" alt="${user.displayName}">
                <span>${user.displayName}</span>
            </div>
        `).join('');
    }

    checkParticipantLimit(participants) {
        const participantCount = Object.keys(participants).length;
        const isWriting = document.querySelector('.writing-area')?.style.display !== 'none';
        
        if (participantCount >= 5 && !participants[this.currentUser.uid] && isWriting) {
            this.handleFullStory();
        }
    }

    handleFullStory() {
        const message = document.querySelector('.message');
        if (message) {
            message.innerHTML = `
                <div class="error-message">
                    <i class="fas fa-users"></i>
                    <span>This story has reached its maximum number of writers.</span>
                </div>
            `;
        }
    }

    handleDisconnect() {
        window.addEventListener('beforeunload', () => {
            if (this.userPresenceRef) {
                set(this.userPresenceRef, {
                    ...this.currentUser,
                    lastActive: serverTimestamp(),
                    isActive: false
                });
            }
        });
    }

    async cleanup() {
        if (this.userPresenceRef) {
            try {
                await remove(this.userPresenceRef);
            } catch (error) {
                console.error('Error cleaning up collaboration:', error);
            }
        }
    }
}

      // UI Functions
      async function setupCustomPrompts() {
        if (!currentUser) return;

        const promptsRef = ref(
          database,
          `users/${currentUser.uid}/customPrompts`
        );
        const snapshot = await get(promptsRef);
        const customPrompts = snapshot.val() || {};
        updateCustomPromptsUI(customPrompts);
      }

      function updateCustomPromptsUI(prompts) {
        const container = document.querySelector('.custom-prompts');
        if (!container) return;

        container.innerHTML = Object.entries(prompts)
          .map(
            ([id, prompt]) => `
            <div class="prompt-item">
                <span>${prompt.text}</span>
                <button onclick="deleteCustomPrompt('${id}')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `
          )
          .join('');
      }

      function updateCustomMoodsUI(moods) {
        const container = document.querySelector('.mood-selector');
        const addButton = container.querySelector('.add-mood-button');
        if (!container || !addButton) return;

        // Remove old custom moods
        document
          .querySelectorAll('.mood-button.custom')
          .forEach((btn) => btn.remove());

        // Add new custom moods before the add button
        Object.entries(moods).forEach(([id, mood]) => {
          const button = document.createElement('button');
          button.className = 'mood-button custom';
          button.dataset.mood = mood.name.toLowerCase();
          button.innerHTML = `
            <i class="fas fa-star"></i>
            ${mood.name}
        `;
          button.addEventListener('click', () => {
            document
              .querySelectorAll('.mood-button')
              .forEach((b) => b.classList.remove('active'));
            button.classList.add('active');
            currentMood = mood.name.toLowerCase();
            updatePrompt(currentMood);
          });
          container.insertBefore(button, addButton);
        });
      }

      function setupMoodButtons() {
        const buttons = document.querySelectorAll(
          '.mood-button:not(.add-mood-button)'
        );
        buttons.forEach((button) => {
          button.addEventListener('click', () => {
            buttons.forEach((b) => b.classList.remove('active'));
            button.classList.add('active');
            currentMood = button.dataset.mood;
            updatePrompt(currentMood);
          });
        });

        // Set initial active mood
        const initialMoodButton = document.querySelector(
          `.mood-button[data-mood="${currentMood}"]`
        );
        if (initialMoodButton) {
          initialMoodButton.classList.add('active');
        }
      }

      function updateCollaboratorsUI(participants) {
        const container = document.getElementById('activeWriters');
        if (!container) return;

        container.innerHTML = Object.entries(participants)
          .map(
            ([uid, user]) => `
            <div class="collaborator">
                <img src="${user.photoURL}" alt="${user.displayName}">
                <span>${user.displayName}</span>
            </div>
        `
          )
          .join('');
      }

      function updateViewersUI(viewers) {
  const container = document.getElementById('activeViewers');
  const viewerCount = document.getElementById('viewerCount');
  
  // Get current writers to filter them out
  const writersRef = ref(database, `stories/${currentStoryId}/participants`);
  get(writersRef).then((snapshot) => {
    const writers = snapshot.val() || {};
    const writerIds = Object.keys(writers);
    
    // Filter out writers from viewers list
    const filteredViewers = Object.entries(viewers).reduce((acc, [uid, viewer]) => {
      if (!writerIds.includes(uid)) {
        acc[uid] = viewer;
      }
      return acc;
    }, {});

    if (viewerCount) {
      viewerCount.textContent = Object.keys(filteredViewers).length;
    }

    if (container) {
      container.innerHTML = Object.entries(filteredViewers)
        .map(([uid, viewer]) => `
          <div class="viewer">
            <img src="${viewer.photoURL}" alt="${viewer.displayName}">
            <span>${viewer.displayName}</span>
            ${viewer.isTyping ? '<span class="typing-indicator">typing...</span>' : ''}
          </div>
        `).join('');
    }
  });
}

      

      // Achievement Functions
      async function checkAchievements(contribution) {
        const userAchievementsRef = ref(
          database,
          `users/${currentUser.uid}/achievements`
        );
        const snapshot = await get(userAchievementsRef);
        const earnedAchievements = snapshot.val() || {};

        const wordCount = contribution.split(/\s+/).length;
        const hour = new Date().getHours();

        if (!earnedAchievements.firstStory) {
          await unlockAchievement('firstStory');
        }

        if (wordCount > 100 && !earnedAchievements.speedWriter) {
          await unlockAchievement('speedWriter');
        }

        if (hour >= 0 && hour < 4 && !earnedAchievements.nightOwl) {
          await unlockAchievement('nightOwl');
        }
      }

      class TimerManager {
    constructor(storyId) {
        this.storyId = storyId;
        this.timerRef = ref(database, `stories/${storyId}/timer`);
    }

    async startTimer() {
        const timestamp = Date.now();
        await set(this.timerRef, {
            startTime: timestamp,
            endTime: timestamp + 45000
        });
    }

    initializeTimerSync() {
        onValue(this.timerRef, (snapshot) => {
            const timerData = snapshot.val();
            if (timerData) {
                const remaining = Math.floor((timerData.endTime - Date.now()) / 1000);
                this.updateTimerDisplay(Math.max(0, remaining));
            }
        });
    }
}

class PhaseManager {
    constructor(storyId) {
        this.storyId = storyId;
        this.phaseRef = ref(database, `stories/${storyId}/phase`);
    }

    async setPhase(phase) {
        await set(this.phaseRef, {
            currentPhase: phase,
            timestamp: serverTimestamp()
        });
    }

    listenToPhaseChanges(callback) {
        onValue(this.phaseRef, (snapshot) => {
            const phaseData = snapshot.val();
            if (phaseData) {
                callback(phaseData.currentPhase);
            }
        });
    }
}

      async function unlockAchievement(achievementId) {
        const achievement = achievements[achievementId];
        const userAchievementsRef = ref(
          database,
          `users/${currentUser.uid}/achievements/${achievementId}`
        );

        await set(userAchievementsRef, {
          ...achievement,
          unlockedAt: Date.now(),
        });

        showAchievementNotification(achievement);
      }

      function showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className =
          'achievement-notification animate__animated animate__slideInRight';
        notification.innerHTML = `
        <i class="fas ${achievement.icon}"></i>
        <div class="achievement-details">
            <h4>${achievement.title}</h4>
            <p>${achievement.description}</p>
        </div>
    `;

        document.body.appendChild(notification);
        setTimeout(() => {
          notification.classList.replace(
            'animate__slideInRight',
            'animate__slideOutRight'
          );
          setTimeout(() => notification.remove(), 1000);
        }, 3000);
      }

      // Content Management Functions
      async function loadUserCustomContent() {
        if (!currentUser) return;

        const customPromptsRef = ref(
          database,
          `users/${currentUser.uid}/customPrompts`
        );
        const customMoodsRef = ref(
          database,
          `users/${currentUser.uid}/customMoods`
        );

        onValue(customPromptsRef, (snapshot) => {
          const prompts = snapshot.val() || {};
          updateCustomPromptsUI(prompts);
        });

        onValue(customMoodsRef, (snapshot) => {
          const moods = snapshot.val() || {};
          updateCustomMoodsUI(moods);
        });
      }

      async function saveCustomPrompt() {
        const promptInput = document.getElementById('newPromptInput');
        if (!promptInput || !currentUser) return;

        const prompt = promptInput.value.trim();
        if (prompt) {
          try {
            const promptRef = ref(
              database,
              `users/${currentUser.uid}/customPrompts`
            );
            const newPromptRef = push(promptRef);
            await set(newPromptRef, {
              text: prompt,
              createdAt: Date.now(),
            });

            promptInput.value = '';
            closeModal('addPromptModal');
          } catch (error) {
            console.error('Error saving custom prompt:', error);
          }
        }
      }

      class ErrorHandler {
    static async handleError(error, context) {
        console.error(`Error in ${context}:`, error);
        
        // Store error for analytics
        await set(ref(database, `errors/${Date.now()}`), {
            error: error.message,
            context,
            userId: currentUser?.uid,
            timestamp: serverTimestamp()
        });

        // Show user-friendly error message
        const message = document.querySelector('.message');
        if (message) {
            message.innerHTML = `
                <div class="error-message">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>Something went wrong. Please refresh the page.</span>
                </div>
            `;
        }

        // Attempt recovery
        if (context === 'timer') {
            storyFlowManager.restartTimer();
        } else if (context === 'phase') {
            storyFlowManager.resyncPhase();
        }
    }
}

      async function saveCustomMood() {
        const moodInput = document.getElementById('newMoodInput');
        if (!moodInput || !currentUser) return;

        const mood = moodInput.value.trim();
        if (mood) {
          try {
            const moodRef = ref(
              database,
              `users/${currentUser.uid}/customMoods`
            );
            const newMoodRef = push(moodRef);
            await set(newMoodRef, {
              name: mood,
              createdAt: Date.now(),
            });

            moodInput.value = '';
            closeModal('addMoodModal');
          } catch (error) {
            console.error('Error saving custom mood:', error);
          }
        }
      }

      // Story Management Functions
      async function leaveCurrentStory() {
        if (!currentStoryId || !currentUser) return;

        try {
          const participantRef = ref(
            database,
            `stories/${currentStoryId}/participants/${currentUser.uid}`
          );
          await remove(participantRef);
        } catch (error) {
          console.error('Error leaving story:', error);
        }
      }

      // Global Window Functions
      window.showAddPromptModal = () => {
        const modal = document.getElementById('addPromptModal');
        if (modal) modal.style.display = 'flex';
      };

      window.showAddMoodModal = () => {
        const modal = document.getElementById('addMoodModal');
        if (modal) modal.style.display = 'flex';
      };

      window.closeModal = (id) => {
        const modal = document.getElementById(id);
        if (modal) modal.style.display = 'none';
      };

      window.saveCustomPrompt = saveCustomPrompt;
      window.saveCustomMood = saveCustomMood;

      window.deleteCustomPrompt = async (id) => {
        if (!currentUser) return;
        try {
          await remove(
            ref(database, `users/${currentUser.uid}/customPrompts/${id}`)
          );
        } catch (error) {
          console.error('Error deleting prompt:', error);
        }
      };

      window.startNewStory = async () => {
        try {
          if (currentStoryId) {
            await leaveCurrentStory();
          }

          const storyFlowManager = new StoryFlowManager();
          await storyFlowManager.initialize();

          const postContribution = document.querySelector('.post-contribution');
          if (postContribution) {
            postContribution.classList.remove('show');
          }
        } catch (error) {
          console.error('Error starting new story:', error);
          alert('Error starting new story. Please try again.');
        }
      };

      window.continueCollaborating = () => {
        const postContribution = document.querySelector('.post-contribution');
        if (postContribution) {
          postContribution.classList.remove('show');
        }
        if (window.storyFlowManager) {
          window.storyFlowManager.startNewRound();
        }
      };

      window.addReaction = async (contributionId, reactionType) => {
        if (!currentUser || !currentStoryId) return;

        try {
          const reactionRef = ref(
            database,
            `stories/${currentStoryId}/contributions/${contributionId}/reactions/${reactionType}`
          );
          const snapshot = await get(reactionRef);
          const reactions = snapshot.val() || [];

          const userIndex = reactions.indexOf(currentUser.uid);

          if (userIndex > -1) {
            reactions.splice(userIndex, 1);
          } else {
            reactions.push(currentUser.uid);
            const button = document.querySelector(
              `[onclick="addReaction('${contributionId}', '${reactionType}')"]`
            );
            if (button) {
              button.classList.add('reaction-pop');
              setTimeout(() => button.classList.remove('reaction-pop'), 300);
            }
          }

          await set(reactionRef, reactions);
        } catch (error) {
          console.error('Error adding reaction:', error);
        }
      };

      // Initialize App
      async function initializeAppFeatures() {
    console.log('Initializing app features...');
    try {
        if (!appState.currentUser) {
            throw new Error('User not authenticated');
        }

        // Test database access
        const testRef = ref(database, `users/${appState.currentUser.uid}/test`);
        try {
            await set(testRef, { timestamp: Date.now() });
            await remove(testRef);
            console.log('Database access verified');
        } catch (error) {
            throw new Error('Database access denied');
        }

        // Initialize features
        await loadUserCustomContent();
        setupMoodButtons();
        await setupCustomPrompts();
        updatePrompt(appState.currentMood);

        // Initialize story flow manager
        window.storyFlowManager = new StoryFlowManager();
        await window.storyFlowManager.initialize();

    } catch (error) {
        ErrorHandler.handleError(error, 'app_initialization');
    }
}

      // Initialize Auth State Observer
      onAuthStateChanged(auth, (user) => {
    if (user) {
        appState.update({ currentUser: user });
        initializeAppFeatures();
    } else {
        window.location.href = 'index.html';
    }
});

    </script>
  </body>
</html>
